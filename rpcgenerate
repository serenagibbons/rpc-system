#!/bin/env python3

# --------------------------------------------------------------
# File: rpcgenerate
# Author: Serena GIbbons
# --------------------------------------------------------------

import argparse
import os
import re
import json
import subprocess

IDL_TO_JSON_EXECUTABLE = "./idl_to_json"

TYPE_OF_TYPES = ["builtin", "struct", "array"]
BUILTIN_TYPES = ["void", "int", "float", "string"]

def idl_to_json(filename):
    """
    Create the JSON representation of the IDL file using idl_to_json.cpp and
    return the parsed ddeclarations in a Python dictionary 
    """
    # Make sure IDL file exists and is readable
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable" 

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))
    
    return decls

def generate_headers(idl_filename, file_type):
    """
    Generate the list of header files and namespaces to include
    """
    header_files = (
        "#include <string>\n"
        "using namespace std;\n"
        "#include <iostream>\n"
        "#include <vector>\n"
        "#include <cstring>\n"
        "#include <cstdio>\n"
        "#include \"" + idl_filename +"\"\n"
        "#include \"rpc" + file_type + "helper.h\"\n"
        "#include \"c150debug.h\"\n"
        "#include \"buffer.h\"\n"
        "#include \"serializer.h\"\n"
        "#include \"deserializer.h\"\n"
        "using namespace C150NETWORK;\n")
   
    return header_files

def generate_proxy(decls):
    """
    Generate the proxy code
    """
    remote_functions = ""
    type_set, struct_info = get_type_set(decls)
    print("type_set:")
    print(type_set)
    print("struct_info:")
    print(struct_info)
    functions = decls["functions"]

    serializers, serializer_contract, deserializers, deserializer_contract = generate_serializers_and_deserializers(
        type_set, struct_info, "proxy")
    
    remote_functions += (serializer_contract + deserializer_contract + serializers + deserializers)

    for name, sig in functions.items():
        args = sig["arguments"]
        return_type = sig["return_type"]
        remote_functions += generate_remote_function(name, args, return_type)

    return remote_functions

def generate_remote_function(function_name, args, return_type):
    """
    Generate the remote function
    """
    # Build argument string and serialization function calls
    arg_string_list = []
    serialize_calls = []
    for arg in args:
        arg_declaration, serializer_call = parse_argument(arg)
        arg_string_list.append(arg_declaration)
        serialize_calls.append(serializer_call)
    
    arg_string = ", ".join(arg_string_list)
    serialize_args = "\n\t".join(serialize_calls)

    # Determine function ending based on return type
    if return_type in {"string", "int", "float"}:
        end = (f"\t{return_type} result = deserialize{return_type.capitalize()}(RPCPROXYSOCKET);\n"
               "\treturn result;\n")
    elif return_type == "void":
        end = ("\tstring result = deserializeString(RPCPROXYSOCKET);\n"
                 "\tif (result.compare(\"DONE\") != 0) {\n"
                 "\t\tthrow C150Exception("
                 f"\"{function_name}() received invalid response from the server\");\n"
                 "\t}\n")
    else:
        end = f"\t{return_type} res;\n\tdeserialize{return_type}(&res);\n\treturn res;\n"

    # Construct the function body
    body = (f"\tBuffer b;\n"
              f"\tserialize(&b, \"{function_name}\");\n"
              f"\t{serialize_args}\n"
              f"\tRPCPROXYSOCKET->write(b.buf, b.length);\n"
              f"\tb.reset();\n"
              f"{end}")

    # Construct the complete remote function
    remote_function = (f"{return_type} {function_name}({arg_string}) {{\n"
                       f"{body}}}\n")

    return remote_function

def parse_argument(arg):
        """
        Helper function to parse an argument and generate the arg string and serializer call.
        """
        arg_type = arg["type"]
        arg_name = arg["name"]
        
        if '[' in arg_type:
            arg_type_clean = arg_type[2:]
            arg_inner_type = arg_type_clean.split('[', 1)[0]
            arg_size_bracket = '[' + arg_type_clean.split('[', 1)[1]
            arg_declaration = f"{arg_inner_type} {arg_name}{arg_size_bracket}"
        else:
            arg_declaration = f"{arg_type} {arg_name}"
        
        # Prepare serializer call
        serializer_call = f"serialize(&b, {arg_name});"
        
        return arg_declaration, serializer_call

def generate_stub(decls):
    """
    Generates stub code for the given functions.
    """
    stub_code = ""
    dispatcher_deserializers = ""
    functions = decls["functions"]
    type_set, struct_info = get_type_set(decls)

    serializers, serializer_contract, deserializers, deserializer_contract = generate_serializers_and_deserializers(
        type_set, struct_info, "stub")
    
    stub_code += (serializer_contract + deserializer_contract + serializers + deserializers)

    for name, sig in functions.items():
        args = sig["arguments"]
        return_type = sig["return_type"]

        # Generate local function for each RPC function
        stub_code += generate_local_functions(name, args, return_type)

        # Generate argument deserialization and dispatcher logic
        arg_names = ", ".join([arg["name"] for arg in args])
        arg_deserializers = ""

        for arg in args:
            arg_type = arg["type"]
            if arg_type in {"string", "int", "float"}:
                arg_deserializers += (
                    f"\t\t\t{arg_type} {arg['name']} = deserialize{arg_type.capitalize()}(RPCSTUBSOCKET);\n"
                )
            # TODO: Add other argument types

        # Call the corresponding local function
        arg_deserializers += f"\t\t\t__{name}({arg_names});\n"
        dispatcher_deserializers += (
            f"\t\telse if (func_name == \"{name}\") {{\n"
            f"{arg_deserializers}\t\t}}\n"
        )

    # Dispatcher function body
    dispatcher_body = (
        "\tif (!RPCSTUBSOCKET->eof()) {\n"
        "\t\tstring func_name = deserializeString(RPCSTUBSOCKET);\n"
        "\t\tif (func_name.compare(\"\") == 0) return;\n"
        f"{dispatcher_deserializers}"
        "\t\telse {\n"
        "\t\t\tthrow C150Exception(\"Error: invalid function.\");\n"
        "\t\t}\n"
        "\t}\n"
    )

    # Complete dispatcher function
    dispatcher = f"void dispatchFunction() {{\n{dispatcher_body}}}\n"
    stub_code += dispatcher

    return stub_code

def parse_array(arg_type):
    """
    Parses array type arguments to extract inner type and size.
    """
    arg_type_clean = arg_type[2:]
    arg_inner_type = arg_type_clean.split('[', 1)[0]
    arg_size_bracket = '[' + arg_type_clean.split('[', 1)[1]
    return arg_inner_type, arg_size_bracket

def generate_local_functions(function_name, args, return_type):
    """
    Generates the local function stub for an RPC function.
    """
    arg_string = ""
    arg_names = ", ".join([arg["name"] for arg in args])

    # Build argument list for the function signature
    for i, arg in enumerate(args):
        arg_type = arg["type"]
        arg_name = arg["name"]

        if '[' in arg_type:  # Handle array types
            arg_inner_type, arg_size_bracket = parse_array(arg_type)
            arg_string += f"{', ' if i > 0 else ''}{arg_inner_type} {arg_name}{arg_size_bracket}"
        else:
            arg_string += f"{', ' if i > 0 else ''}{arg_type} {arg_name}"

    # Generate function call and serialization logic
    if return_type == "void":
        function_call = f"\t{function_name}({arg_names});\n\tstring result = \"DONE\";\n"
        serialize_call = "\tserialize(&b, result);\n"
    else:
        function_call = f"\t{return_type} result = {function_name}({arg_names});\n"
        serialize_call = "\tserialize(&b, result);\n"

    # Function body
    body = (
        "\tBuffer b;\n"
        f"{serialize_call}"
        "\tRPCSTUBSOCKET->write(b.buf, b.length);\n"
        "\tb.reset();\n"
    )

    # Combine into the local function definition
    local_function = (
        f"void __{function_name}({arg_string}) {{\n"
        f"{function_call}"
        f"{body}}}\n"
    )

    return local_function

def get_type_set(decls):
    """
    Extract types from function arguments, return types, and structs, including struct members.
    
    Returns:
        tuple: A set of types, and a list of struct details (names and members).
    """
    type_set = set()  # Set to store unique types
    struct_arr = []   # List to store details of structs
    functions = decls["functions"]
    types = decls["types"]

    # Process function declarations
    for func_name, func_sig in functions.items():
        # Add argument types to the type set
        for arg in func_sig["arguments"]:
            type_set.add(arg["type"])
        # Add return type to the type set
        type_set.add(func_sig["return_type"])

    # Process type declarations (structs and arrays)
    for type_name, type_sig in types.items():
        type_of_type = type_sig["type_of_type"]

        if type_of_type == "struct":
            # Add struct name to the type set
            type_set.add(type_name)
            
            # Gather struct member details
            struct_details = {"struct_name": type_name, "mem_name": [], "mem_type": []}
            for member in type_sig["members"]:
                type_set.add(member["type"])  # Add member type to the type set
                struct_details["mem_name"].append(member["name"])
                struct_details["mem_type"].append(member["type"])

            struct_arr.append(struct_details)

        elif type_of_type == "array":
            # Add array name and its member type to the type set
            type_set.add(type_name)
            type_set.add(type_sig["member_type"])

    return type_set, struct_arr


def generate_serializers_and_deserializers(type_set, struct_info, file_type):
    """
    Genereate serializer and deserializer functions and forward declarations.
    """
    serializers = ""
    serializer_contracts = ""
    deserializers = ""
    deserializer_contracts = ""

    for type_of_type in type_set:
        if type_of_type not in BUILTIN_TYPES:
            serializer, serializer_contract = generate_serializer(type_of_type, struct_info)
            serializers += serializer
            serializer_contracts += serializer_contract
            deserializer, deserializer_contract = generate_deserializer(type_of_type, struct_info, file_type)
            deserializers += deserializer
            deserializer_contracts += deserializer_contract
    
    return serializers, serializer_contracts, deserializers, deserializer_contracts

def generate_serializer(type_of_type, struct_info):
    """
    Generate function to serialize a struct.
    """
    serializer_body = ""
    for struct in struct_info:
        if struct["struct_name"] == type_of_type:
            for mem_name, mem_type in zip(struct["mem_name"], struct["mem_type"]):
                formatted_mem_type = mem_type.replace('][', '_').replace('[', '_').replace(']', '_')
                serializer_body += f"\t{formatted_mem_type}serialize(b, {type_of_type[0]}1.{mem_name});\n"

    serializer = f"void serialize{type_of_type}(Buffer *b, {type_of_type} {type_of_type[0]}1) {{\n{serializer_body}}}\n"
    serializer_contract = f"void serialize{type_of_type}(Buffer *b, {type_of_type} {type_of_type[0]}1);\n"
    
    return serializer, serializer_contract

def generate_deserializer(type_of_type, struct_info, file_type):
    var = f"{type_of_type[0]}1"
    deserializer_body = ""
    for struct in struct_info:
        if struct["struct_name"] == type_of_type:
            for mem_name, mem_type in zip(struct["mem_name"], struct["mem_type"]):
                if mem_type in {"string", "int", "float"}:
                    deserializer_body += f"\t{var}->{mem_name} = deserialize{mem_type.capitalize()}(RPC{file_type.upper()}SOCKET);\n"
                else:
                    formatted_mem_type = mem_type.replace('][', '_').replace('[', '_').replace(']', '_')
                    if '[' in mem_type:
                        deserializer_body += f"\tdeserialize{formatted_mem_type}({var}->{mem_name});\n"
                    else:
                        deserializer_body += f"\tdeserialize{formatted_mem_type}(&({var}->{mem_name}));\n"

    deserializer = f"void deserialize{type_of_type} ({type_of_type} *{var}) {{\n{deserializer_body}}}\n"
    deserializer_contract = f"void deserialize{type_of_type} ({type_of_type} *{var});\n"
    
    return deserializer, deserializer_contract

def main():
    """
    Generate the RPC proxy and stub files from the given idl file.
    Command line: python rpcgenerate <idl_filepath>
    """
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('idl_filepath')
    args = parser.parse_args()

    # Set idl file path
    idl_filepath = args.idl_filepath
    idl_filename = os.path.basename(idl_filepath)

    # Parse declarations into a Python dictionary
    decls = idl_to_json(idl_filepath)
    json_string = json.dumps(decls, indent=4)
    print(json_string)

    # Set proxy and stub file names
    proxy_filename = re.sub(r'\.idl', '.proxy.cpp', idl_filename)
    stub_filename = re.sub(r'\.idl', '.stub.cpp', idl_filename)

    # Generate the header files and namespaces
    proxy_headers = generate_headers(idl_filename, 'proxy')
    stub_headers = generate_headers(idl_filename, 'stub')

    # Generate code
    proxy_code = generate_proxy(decls)
    stub_code = generate_stub(decls)

    print(proxy_filename + ":\n" + proxy_code)
    print(stub_filename + ":\n" +stub_code)

    # Write the proxy code to the proxy file
    with open(proxy_filename, "w") as f:
        f.writelines([proxy_headers, proxy_code])

    # Write the stub code to the stub file
    with open(stub_filename, "w") as f:
        f.writelines([stub_headers, stub_code])

if __name__=="__main__":
	main()