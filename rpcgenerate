#!/bin/env python3

# --------------------------------------------------------------
# File: rpcgenerate
# Author: Serena GIbbons
# --------------------------------------------------------------

import argparse
import os
import re
import json
import subprocess

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

TYPE_OF_TYPES = ['builtin', 'struct', 'array']
BUILTIN_TYPES = ['void', 'int', 'float', 'string']

def idl_to_json(filename):
    """
    Create the JSON representation of the IDL file using idl_to_json.cpp and
    return the parsed ddeclarations in a Python dictionary 
    """
    # Make sure IDL file exists and is readable
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable" 

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))
    
    return decls

def generate_headers(idl_filename, file_type):
    """
    Generate the list of header files and namespaces to include
    """
    header_files = (
        "#include <string>\n"
        "using namespace std;\n"
        "#include <iostream>\n"
        "#include <vector>\n"
        "#include <cstring>\n"
        "#include <cstdio>\n"
        "#include \"" + idl_filename +"\"\n"
        "#include \"rpc" + file_type + "helper.h\"\n"
        "#include \"c150debug.h\"\n"
        "#include \"buffer.h\"\n"
        "#include \"serializer.h\"\n"
        "#include \"deserializer.h\"\n"
        "using namespace C150NETWORK;\n")
   
    return header_files

def generate_proxy(functions):
    """
    Generate the proxy code
    """
    remote_functions = ""
    for name, sig in functions.items():
        args = sig["arguments"]
        return_type = sig["return_type"]
        remote_functions += generate_remote_function(name, args, return_type)
    return remote_functions

def generate_remote_function(function_name, args, return_type):
    """
    Generate the remote function
    """
    # Build argument string and serialization function calls
    arg_string_list = []
    serialize_calls = []
    for arg in args:
        arg_declaration, serializer_call = parse_argument(arg)
        arg_string_list.append(arg_declaration)
        serialize_calls.append(serializer_call)
    
    arg_string = ", ".join(arg_string_list)
    serialize_args = "\n\t".join(serialize_calls)

    # Determine function ending based on return type
    if return_type in {"string", "int", "float"}:
        end = (f"\t{return_type} result = deserialize{return_type.capitalize()}(RPCPROXYSOCKET);\n"
               "\treturn result;\n")
    elif return_type == "void":
        end = ("\tstring result = deserializeString(RPCPROXYSOCKET);\n"
                 "\tif (result.compare(\"DONE\") != 0) {\n"
                 "\t\tthrow C150Exception("
                 f"\"{function_name}() received invalid response from the server\");\n"
                 "\t}\n")
    #TODO: Add other return types

    # Construct the function body
    body = (f"\tBuffer b;\n"
              f"\tserialize(&b, \"{function_name}\");\n"
              f"\t{serialize_args}\n"
              f"\tRPCPROXYSOCKET->write(b.buf, b.length);\n"
              f"\tb.reset();\n"
              f"{end}")

    # Construct the complete remote function
    remote_function = (f"{return_type} {function_name}({arg_string}) {{\n"
                       f"{body}}}\n")

    return remote_function

def parse_argument(arg):
        """
        Helper function to parse an argument and generate the arg string and serializer call.
        """
        arg_type = arg["type"]
        arg_name = arg["name"]
        
        if '[' in arg_type:
            arg_type_clean = arg_type[2:]
            arg_inner_type = arg_type_clean.split('[', 1)[0]
            arg_size_bracket = '[' + arg_type_clean.split('[', 1)[1]
            arg_declaration = f"{arg_inner_type} {arg_name}{arg_size_bracket}"
        else:
            arg_declaration = f"{arg_type} {arg_name}"
        
        # Prepare serializer call
        serializer_call = f"serialize(&b, {arg_name});"
        
        return arg_declaration, serializer_call


def generate_stub(functions):
    """
    Generates stub code for the given functions.
    """
    stub_code = ""
    dispatcher_deserializers = ""

    for name, sig in functions.items():
        args = sig["arguments"]
        return_type = sig["return_type"]

        # Generate local function for each RPC function
        stub_code += generate_local_functions(name, args, return_type)

        # Generate argument deserialization and dispatcher logic
        arg_names = ', '.join([arg["name"] for arg in args])
        arg_deserializers = ""

        for arg in args:
            arg_type = arg["type"]
            if arg_type in {"string", "int", "float"}:
                arg_deserializers += (
                    f"\t\t\t{arg_type} {arg['name']} = deserialize{arg_type.capitalize()}(RPCSTUBSOCKET);\n"
                )
            # TODO: Add other argument types

        # Call the corresponding local function
        arg_deserializers += f"\t\t\t__{name}({arg_names});\n"
        dispatcher_deserializers += (
            f"\t\telse if (func_name == \"{name}\") {{\n"
            f"{arg_deserializers}\t\t}}\n"
        )

    # Dispatcher function body
    dispatcher_body = (
        "\tif (!RPCSTUBSOCKET->eof()) {\n"
        "\t\tstring func_name = deserializeString(RPCSTUBSOCKET);\n"
        "\t\tif (func_name.compare(\"\") == 0) return;\n"
        f"{dispatcher_deserializers}"
        "\t\telse {\n"
        "\t\t\tthrow C150Exception(\"Error: invalid function.\");\n"
        "\t\t}\n"
        "\t}\n"
    )

    # Complete dispatcher function
    dispatcher = f"void dispatchFunction() {{\n{dispatcher_body}}}\n"
    stub_code += dispatcher

    return stub_code

def parse_array(arg_type):
    """
    Parses array type arguments to extract inner type and size.
    """
    arg_type_clean = arg_type[2:]
    arg_inner_type = arg_type_clean.split('[', 1)[0]
    arg_size_bracket = '[' + arg_type_clean.split('[', 1)[1]
    return arg_inner_type, arg_size_bracket

def generate_local_functions(function_name, args, return_type):
    """
    Generates the local function stub for an RPC function.
    """
    arg_string = ""
    arg_names = ', '.join([arg["name"] for arg in args])

    # Build argument list for the function signature
    for i, arg in enumerate(args):
        arg_type = arg["type"]
        arg_name = arg["name"]

        if '[' in arg_type:  # Handle array types
            arg_inner_type, arg_size_bracket = parse_array(arg_type)
            arg_string += f"{', ' if i > 0 else ''}{arg_inner_type} {arg_name}{arg_size_bracket}"
        else:
            arg_string += f"{', ' if i > 0 else ''}{arg_type} {arg_name}"

    # Generate function call and serialization logic
    if return_type == "void":
        function_call = f"\t{function_name}({arg_names});\n\tstring result = \"DONE\";\n"
        serialize_call = "\tserialize(&b, result);\n"
    else:
        function_call = f"\t{return_type} result = {function_name}({arg_names});\n"
        serialize_call = "\tserialize(&b, result);\n"

    # Function body
    body = (
        "\tBuffer b;\n"
        f"{serialize_call}"
        "\tRPCSTUBSOCKET->write(b.buf, b.length);\n"
        "\tb.reset();\n"
    )

    # Combine into the local function definition
    local_function = (
        f"void __{function_name}({arg_string}) {{\n"
        f"{function_call}"
        f"{body}}}\n"
    )

    return local_function

def main():
    """
    Generate the RPC proxy and stub files from the given idl file.
    Command line: python rpcgenerate <idl_filepath>
    """
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('idl_filepath')
    args = parser.parse_args()

    # Set idl file path
    idl_filepath = args.idl_filepath
    idl_filename = os.path.basename(idl_filepath)

    # Parse declarations into a Python dictionary
    decls = idl_to_json(idl_filepath)
    json_string = json.dumps(decls, indent=4)
    print(json_string)

    # Get types and functions
    types = decls['types']
    functions = decls['functions']

    # Set proxy and stub file names
    proxy_filename = re.sub(r'\.idl', '.proxy.cpp', idl_filename)
    stub_filename = re.sub(r'\.idl', '.stub.cpp', idl_filename)

    # Generate the header files and namespaces
    proxy_headers = generate_headers(idl_filename, 'proxy')
    stub_headers = generate_headers(idl_filename, 'stub')

    # Generate code
    proxy_code = generate_proxy(functions)
    stub_code = generate_stub(functions)

    print(proxy_filename + ":\n" + proxy_code)
    print(stub_filename + ":\n" +stub_code)

    # Write the proxy code to the proxy file
    with open(proxy_filename, 'w') as f:
        f.writelines([proxy_headers, proxy_code])

    # Write the stub code to the stub file
    with open(stub_filename, 'w') as f:
        f.writelines([stub_headers, stub_code])

if __name__=="__main__":
	main()