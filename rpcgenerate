#!/bin/env python3

import argparse
import os
import re
import json
import subprocess

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

def idl_to_json(filename):
    """
    Create the JSON representation of the IDL file using idl_to_json.cpp and
    return the parsed ddeclarations in a Python dictionary 
    """
    # Make sure IDL file exists and is readable
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable" 

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))
    
    return decls

def main():
    """
    Command line: python rpcgenerate <idl_filepath>
    """
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('idl_filepath')
    args = parser.parse_args()

    # Set idl file path
    idl_filepath = args.idl_filepath
    idl_filename = os.path.basename(idl_filepath)
    
    # Set proxy and stub file names
    proxy_filename = re.sub(r'\.idl', '.proxy.cpp', idl_filename)
    stub_filename = re.sub(r'\.idl', '.stub.cpp', idl_filename)

    # Parse declarations into a Python dictionary
    decls = idl_to_json(idl_filepath)
    json_string = json.dumps(decls, indent=4)
    print(json_string)

    # Get types and functions
    types = decls["types"]
    functions = decls["functions"]

    # Generate the include statement for the IDL file
    idl_include = f"#include \"{idl_filename}\""
    print(idl_include)

if __name__=="__main__":
	main()